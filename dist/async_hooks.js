var e=1,t=new Map,s=0,r=[];var n=class{constructor(t,n=s){this._type=t,this._asyncId=e++,this._triggerAsyncId=n,r.forEach(e=>{e.enabled&&e.callbacks.init&&e.callbacks.init(this._asyncId,this._type,this._triggerAsyncId,this)})}runInAsyncScope(e,t,...n){let a=s;s=this._asyncId,r.forEach(e=>{e.enabled&&e.callbacks.before&&e.callbacks.before(this._asyncId)});try{return e.apply(t,n)}finally{r.forEach(e=>{e.enabled&&e.callbacks.after&&e.callbacks.after(this._asyncId)}),s=a}}emitDestroy(){r.forEach(e=>{e.enabled&&e.callbacks.destroy&&e.callbacks.destroy(this._asyncId)})}asyncId(){return this._asyncId}triggerAsyncId(){return this._triggerAsyncId}},a=class{constructor(){this._storeMap=new Map}run(e,t,...s){let r=new n("AsyncLocalStorage");return r.runInAsyncScope(()=>{this._storeMap.set(r.asyncId(),e);try{return t(...s)}finally{this._storeMap.delete(r.asyncId())}})}getStore(){return this._storeMap.get(s)}},c=class{constructor(e){this.callbacks=e||{},this.enabled=!1}enable(){return this.enabled||(this.enabled=!0,r.includes(this)||r.push(this)),this}disable(){this.enabled=!1;let e=r.indexOf(this);return-1!==e&&r.splice(e,1),this}};function i(e){return new c(e)}function l(){return s}function o(){let e=t.get(s);return e?e.triggerAsyncId:0}var h=globalThis.setTimeout;globalThis.setTimeout=(e,t,...s)=>{let r=new n("Timeout");return h(()=>{r.runInAsyncScope(()=>{e(...s),r.emitDestroy()})},t)};export{a as AsyncLocalStorage,n as AsyncResource,i as createHook,l as executionAsyncId,o as triggerAsyncId};
/*! For license information please see async_hooks.js.LEGAL.txt */